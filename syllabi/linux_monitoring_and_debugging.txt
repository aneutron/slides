Monitoring and debugging in the Linux environment

Description: This course is intended for programmers who wish to monitor or debug
their C/C++ apps on a Linux system, tune their Linux system to their needs, Modify
the boot process and more.

Objectives:
- Gain an in-depth understanding of how Linux works.
- Learn how to tune the system.
- Learn how to tune your programming style so that you would use the system better.
- Learn how to tune your applications parameters to utilize the system better.
- Gain understanding of the most important topics dealing with writing real time apps on Linux.
- Review some of the most important monitoring tools available.
- Learn how to find problems using these monitoring tools.

Prerequisites:
- Knowledge of command line Unix or Linux.
- C/C++ programming is a real advantage and even a prerequisite since this is an in depth course.

What this course does not cover:
- writing scripts
- interacting with the shell
- login/logout
- using debugger (local or remote)

Last 3 chapters are optional and will be done at the cost of emitting practical exercises.

Duration: 3 days

Topics
======
Kernel introduction
	The definition of a kernel
	Basics of kernel implementation
	Kernel/userspace interface (syscalls, virtual filesystems, libc)
	How much do context switches cost?
	The Linux scheduler (OTHER, FIFO, RR)
	Different kernel contexts (passive, interrupt, kernel threads)
	Different userspace contexts (regular, signal)
Monitoring memory
	top, ps and more
	How the OS allocates RAM
	Being not lazy in RAM allocation
	Swap (adding, removing, monitoring)
	To swap or not to swap
Monitoring applications
	ps and it's many options
	how does /proc work
	the /proc folder per app
	What are zombies? How do you identify them? How do you handle them?
	Controlling affinity of apps
	Limiting apps resources
	strace (standalone and attaching), mtrace, ltrace.
	top and it's many options
	What is a software watchdog?
	Writing a simple linux watchdog
	Using inittab for simple watchdogging
	How does the Linux scheduler work? nice(1), chrt(1)
Monitoring disk
	The mount paradigm
	using du and df correctly
	Difference between disk utilisation and logical size of files
	Seeing all open files of applications
	Controlling disk scheduling priority and class (ioprio).
	iotop(1) and iostat(1)
	sar(1) and other monitoring tools
	The different file systems linux supports
	Implications of file system selection on application performance.
	Controlling file system features.
	ram file systems (tmpfs, ...)
	loopback device.
	basic tools (/dev devices, fdisk, fsck, /etc/fstab)
Monitoring network
	netstat and it's many options
	Monitoring and controlling the OS network stack (/proc).
	ifconfig and it's many options
	monitoring the network interface (ethtool).
	ip(1) and it's many options
	Load balancing and failing over ethernet interfaces (bonding)
	Bridging network interfaces.
	vlans, tunnels, aliases.
	lo and what it's for?
	name resolution and it's problems.
	tap devices.
	routing
	tools (tcpdump, wireshark and more)
Monitoring the kernel
	Seeing kernel threads in ps
	Examining interrupts
	Controlling affinity of interrupt handles
	Interrupt load balancing
	Controlling affinity of kernel threads
	Modules: loading, unloading, monitoring
	sysctl
	real time patch: controlling affinity and priority of interrupt handlers
	udev + demo of udev.
	getting hw info: lspci, lsusb, dmidecode, ...
The boot process (optional)
	The BIOS
	The bootloader
	Configuring grub
	Using other bootloaders (lilo, syslinux, uboot)
	Advantages and disadvantages of certain boot loaders
	The init process
	SysV init
	Upstart
	inittab and how it works
	initrd and initramfs
Embedded Linux systems (optional)
	uboot in detail
	How embedded systems get built? (top down, bottom up)
	Quick review: ptxdist, buildroot, android, yocto, gentoo, distros
	busybox
	libc replacements
RPC (optional)
	basics
	portmapper
	rpcgen
		options + direcives
		complex data structures
		example
